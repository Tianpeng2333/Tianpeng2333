<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>友链</title>
      <link href="9999/12/31/%E5%8F%8B%E9%93%BE/"/>
      <url>9999/12/31/%E5%8F%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h1><h2 id="我自己"><a href="#我自己" class="headerlink" title="我自己"></a>我自己</h2><ul class="flinks"><li>鹏's blog</li><li>https://tianpeng2333.github.io/</li><li>/img/avatar.jpg</li><li>tianpeng2333.github.io</li><li>Do the right thing, do not be evil.</li></ul><h2 id="真-·-友链"><a href="#真-·-友链" class="headerlink" title="真 · 友链"></a>真 · 友链</h2><ul class="flinks"><li>Piggy's Blog</li><li>https://blog.piggy.moe/</li><li>/img/friends/piggy/avatar.jpg</li><li>blog.piggy.moe</li><li>Piggy!</li><li>Pwdding's Dinning Hall</li><li>https://putinspudding.github.io/</li><li>/img/friends/pwdding/avatar.jpg</li><li>putinspudding.github.io</li><li>Pwdding(?)</li><li>@a-fruity-melon</li><li>https://github.com/a-fruity-melon</li><li>/img/friends/a-fruity-melon/avatar.jpg</li><li>github.com/a-fruity-melon</li><li>@shell32.dll,-8508</li><li>信风吹絮的博客</li><li>https://yxzhjzhhh.github.io/</li><li>/img/friends/信风吹絮/avatar.jpg</li><li>yxzhjzhhh.github.io</li><li>一个整日摸鱼蒟蒻的博客</li><li>@MetLee</li><li>https://github.com/MetLee</li><li>/img/friends/metlee/avatar.jpg</li><li>github.com/MetLee</li><li>条条大路通CS</li><li>洛灵酱的小窝</li><li>https://blog.luoling8192.top/</li><li>/img/friends/luoling/avatar.jpg</li><li>blog.luoling8192.top</li><li>想要变可爱</li><li>xlj2596 的博客</li><li>https://www.luogu.com.cn/blog/xlj/</li><li>/img/friends/xlj/avatar.jpg</li><li>luogu.com.cn/blog/xlj</li><li>宇宙无敌大帅比xlj</li><li>Lins的黑科技笔记（?）</li><li>https://www.cnblogs.com/Linsaner/</li><li>/img/friends/Linsaner/avatar.jpg</li><li>cnblogs.com/Linsaner</li><li>CTFer or OIer</li></ul><h2 id="如何加入"><a href="#如何加入" class="headerlink" title="如何加入"></a>如何加入</h2><p>如果您想加上鹏的友链的话<del>（我觉得没多少人会加）</del>请在这个文章下面的评论区里面写下以下内容：</p><ul><li>网站名称</li><li>网站地址(link)</li><li>网站描述(尽量简短一点？box的容纳长度有限qwq)</li><li>网站图标(link)</li></ul><p>这边康到（时间不定）而且感觉可以的话会在这边加上友链并回复的~</p><p>不过在来加友链之前请给鹏也加上友链哦~</p><ul><li>网站名称：鹏’s Blog</li><li>网站地址：<a href="https://tianpeng2333.github.io/">https://tianpeng2333.github.io/</a></li><li>网站描述：Do the right thing, do not be evil.</li><li>网站图标：<a href="https://tianpeng2333.github.io/img/avatar.jpg">https://tianpeng2333.github.io/img/avatar.jpg</a></li></ul><script>    document.querySelectorAll('ul.flinks').forEach(        function (e)         {             let a = e;             if (a)             {                 let ns = a.querySelectorAll("li");                 let str = '<div style="display:inline-block;">';                 let bgid = 0;                 const bgs = ["bg-argon", "bg-blue", "bg-purple", "bg-green", "bg-yellow", "bg-red", "bg-orange"];                 for (let i = 0; i < ns.length; i += 5)                 {                      str += (`<div class="flink-item">                            <div class="flink-title">                                <a href="${ns[i + 1].innerText}"target="_blank"rel="external nofollow ugc" color:"#f1f1f1">${ns[i].innerText}</a>                            </div>                            <div class="flink-link" id="flink-link">                                <div class="flink-link-ico"style="background: url(${ns[i + 2].innerText});background-size: 42px auto;"></div>                                <div class="flink-link-text" style="width:150px">${ns[i + 3].innerText}</div>                            </div>                            <div class="flink-detail">                                <div class="flink-detail-text" style="width:150px">${ns[i + 4].innerText}</div>                            </div>                            </div>`)                 }                 str += `</div>`;                 let n1 = document.createElement("div");                 n1.innerHTML = str;                 a.parentNode.insertBefore(n1, a);                 a.style = "display: none;"             }             else { console.log('No such id "flinks"') } });</script><style>    .flink-item {        width: 300px;        height: 150px;        position: relative;        box-shadow: 0 .150rem .80rem rgba(0,0,0,.075);        margin: 10px;        border-radius: 3px;        float: left    }    .flink-title {        left: 25px;        top: 25px;        position: absolute    }    .flink-title a{        font-size: 17px;        line-height: 17px;        word-break: break-all;        text-decoration: none;        outline: 0    }    .flink-link {        right: 0;        bottom: 0;        padding: 0 15px 15px;        position: absolute;        text-align: center    }    .flink-link-text {        font-size: 10px;        line-height: 15px;        word-wrap:break-word;          word-break:break-all;        overflow: hidden    }    .flink-link-ico {        display: inline-block;        width: 42px;        height: 42px;        border-radius: 50%    }    .flink-detail    {        left: 25px;        top: 65px;        position: absolute    }    .flink-detail-text {        font-size: 10px;        line-height: 15px;        word-wrap:break-word;          word-break:break-all;        overflow: hidden    }    .bg-argon{        background-color: #5e72e4 !important    }    .bg-blue {        background-color: #6fa3ef !important    }    .bg-purple {        background-color: #bc99c4 !important    }    .bg-green {        background-color: #46c47c !important    }    .bg-yellow {        background-color: #f9bb3c !important    }    .bg-red {        background-color: #e8583d !important    }    .bg-orange {        background-color: #f68e5f !important    }</style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《算法竞赛从入门到入坟》的内测碎碎念</title>
      <link href="2021/01/22/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F%E3%80%8B%E7%9A%84%E5%86%85%E6%B5%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>2021/01/22/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F%E3%80%8B%E7%9A%84%E5%86%85%E6%B5%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>咕咕咕，咕咕咕，咕咕咕</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《算法竞赛从入门到入坟》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《前缀函数与 KMP》逐字稿</title>
      <link href="2021/01/22/%E3%80%8A%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8E-KMP%E3%80%8B%E9%80%90%E5%AD%97%E7%A8%BF/"/>
      <url>2021/01/22/%E3%80%8A%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8E-KMP%E3%80%8B%E9%80%90%E5%AD%97%E7%A8%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>你听着 ilem 教主的神作《达拉崩吧》，心生一个问题：这首歌唱了多少遍 “达拉崩吧” 啊？<br>于是你把歌词丢进了 word，查找 “达拉崩吧”，发现出现了 11 次。而这其中又发生了什么？我们能不能写一个程序来去解决这样的问题呢？</p><hr><p>其实刚才的问题抽象一下就是，你有两个字符串 $s$ 和 $t$，需要查找 $t$ 作为 $s$ 的子串的出现次数。为了方便呢，下面我们以 $n$ 代指 $s$ 的长度， $m$ 代指 $t$ 的长度；字符串的第一位我们称为第 0 位，最后一位是第 $n-1$ 位。现在你来写个程序试一试？</p><p>{task-1}</p><p>嗯！不错！但如果我告诉你这个任务其实可以在 $O(n+m)$ 的时间复杂度内完成，你信吗？ </p><p>甭管你信不信，这是事实。下面你将会自己尝试发现这个算法！是不是带劲起来了？我们开始吧。</p><h2 id="前缀函数"><a href="#前缀函数" class="headerlink" title="前缀函数"></a>前缀函数</h2><p>为了完成这个任务，我们先来求一个函数：前缀函数。</p><p>前缀函数的定义其实很简单，对于一个长度为 $n$ 的字符串 $s$，前缀函数 $f(i)$ 指的就是 $s_0 \sim s_i$ 这段子串最长的相等的真前缀和真后缀的长度。</p><p>举个例子，如果字符串 $s$ 是 <code>opoopo</code>，它的前缀函数计算流程就像是这样：</p><ul><li>当 $i=0$ 时：<ul><li>所求子串为 <code>o</code>，它没有真前缀和真后缀，所以 $f(0)=0$。</li></ul></li><li>当 $i=1$ 时：<ul><li>子串变为了 <code>op</code>，真前后缀长度最长是 1，分别是 <code>o</code> 和 <code>p</code>，它们不相等，所以 $f(1)=0$。</li></ul></li><li>当 $i=2$ 时：<ul><li>子串现在是 <code>opo</code>，真前后长度最长是 2：<ul><li>长度为 1 时，真前后缀分别是 <code>o</code> 和 <code>o</code>，它们是相等的。</li><li>长度为 2 时，真前后缀分别是 <code>op</code> 和 <code>po</code>,它们是不等的。</li></ul></li><li>所以最长的相等的真前后缀是 <code>o</code>，$f(2)=1$。</li></ul></li></ul><p>以此类推，最后当 $i=5$ 的时候，相等的前后缀有 <code>o</code> 和 <code>opo</code>，<code>opo</code> 更长，所以 $f(5)=3$。</p><p>现在你知道前缀函数怎么求了，写个最朴素的程序算算试试吧。</p><p>{task-2}</p><p>棒！但如果是朴素求法的话时间复杂度是 $O(n^3)$，属实有点慢，能不能优化一下呢？</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们观察这个程序：</p><pre><code class="c++">vector&lt;int&gt; brute(string s)&#123;    int n=s.length();    vector&lt;int&gt; f(n);    for(int i=1;i&lt;n;++i) //求 f[i]        for(int j=i;j&gt;=0;--j) //枚举前后缀长度            if(s.substr(0,j)==s.substr(i-j+1,j)) //截取前后缀比较            &#123;                f[i]=j;                break;            &#125;    return f;&#125;</code></pre><blockquote><p>在 C++ 中 <code>s.substr(a,b)</code> 可以返回 $s_a \sim s_{a+b-1}$ 这段子串，更形象化一点就是返回 $s$ 以第 $a$ 位为起点的长度为 $b$ 的子串，时间复杂度为 $O(b)$。</p></blockquote><p>求 $f(i)$ 的第一层循环肯定不能省，截取前后缀比较的地方也貌似省不了，能优化的地方应该只有枚举前后缀长度的部分了。如果我们能够知道每一个位置相等的前后缀最长会有多长就可以了……</p><p>你自己试试看能不能找到呢？如果感觉没有思路，尝试自己手工模拟一下对于每个位置求前缀函数的过程或是多求几个字符串的每个位置的前缀函数值找找规律吧。</p><p>{task-3}</p><p>牛！接下来我们来尝试思考一下这几个问题：</p><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p>这个方法的正确性是如何保证的？其实很简单，我们现在有这样的一个字符串 $s =$ <code>abcdab?</code>。注意，我们并不知道 <code>?</code> 处的字符是什么。在这个字符串中，我们可以很轻松的得到 $f(5) = 2$。现在来看看 $f(6)$。如果想要让 $f(6)$ 尽可能的大，我们只能让第 6 位的 <code>?</code> 和第 2 位的 <code>c</code> 相等，得到 $f(6)=3$。</p><p>接下来我们把它抽象一下，变成一个长度为 $n$ 的字符串 $s=s_0s_1 \cdots s_{n-1}$。那么对于一个 $f(i)$，显然只有在 $s_{i+1}=s_{f(i)}$ 的时候 $f(i+1)$ 可以取到最大值 $f(i)+1$，这样我们就把这个优化方式的正确性证完了。</p><h4 id="优化性"><a href="#优化性" class="headerlink" title="优化性"></a>优化性</h4><p>但这个优化貌似有一个致命的缺陷：当字符串仅由一种字符组成的时候，每个 $f(i)$ 都和 $i$ 相等，此时它的性能貌似和之前提到过的 $O(n^3)$ 的暴力算法相近。然而我们只需要取最大值就可以了，所以我们可以逆向计算前后缀的最大值，找到一个合法的值马上跑路，就可以完美的规避这一问题。</p><p>其实在造 Task-3 的数据的时候有专门去卡这种情况，所以能看到这里的你肯定已经采用这种写法了，不过这里还是简单的提一下。</p><h3 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h3><p>让我们再回到求前缀函数上，降掉一维已经是一个巨大的优化了，但其实还可以再进一步，变成线性的时间复杂度！</p><p>回顾一下前一个优化的代码：</p><pre><code class="c++">vector&lt;int&gt; boost1(string str)&#123;    int n = str.length();    vector&lt;int&gt; f(n);    for(int i=1;i&lt;n;++i)        for(int j=f[i-1]+1;j&gt;=0;--j)            if(str.substr(0,j)==str.substr(i-j+1,j))            &#123;                f[i]=j;                break;            &#125;    return f;&#125;</code></pre><p>现在唯一能优化的地方也就只有比较子串的地方了。比较肯定还是要比较，不过要实现线性复杂度的话必须不能比较子串，而是比较字符。</p><p>还记得我们在证明 $O(n^2)$ 做法的正确性中提到了当 $s_{i+1} = s_{f(i)}$ 的时候才存在 $f(i+1)=f(i)+1$ 的情况吗？当 $s_{i+1} \neq s_{f(i)}$ 的时候，我们能不能同样找到一种转移方法呢？</p><p>因为在计算 $f(i+1)$ 的时候新增了一个位于真后缀的 $s_{i+1}$，所以我们来看看 $f(i+1)$ 代表的这段真后缀的组成吧。<br>假设这段真后缀的长度为 $j+1$，那么它一定是由等于 $s_0 \sim s_{j-1}$ 的子串 $s_{i-j+1} \sim s_{i}$ 再加上等于 $s_j$ 的 $s_{i+1}$ 组成的。只要可以快速求出满足这些条件的 $j$，就能通过判定 $s_{i+1}$ 是否等于 $s_{j}$ 来知道 $j$ 是否合法了！</p><p>开始表演吧！</p><blockquote><p>Bonus Hint:<br>我们想要让 $f(i+1)$ 尽可能的大，而 $f(i+1)=j+1$，所以唯一的办法就是让 $j$ 尽可能的大。在前面的过程中，我们得到了 $s_0 \sim s_{j-1} = s_{i-j+1} \sim s_i$。如何找到最长的能够满足这个性质的 $j$ 呢？看看前缀函数 $f(i)$ 的意义？</p></blockquote><p>{task-4}</p><p>太强了！</p><h4 id="为什么是线性的"><a href="#为什么是线性的" class="headerlink" title="为什么是线性的"></a>为什么是线性的</h4><p>看看这段程序：</p><pre><code class="c++">vector&lt;int&gt; boost2(string str)&#123;    int n = str.length();    vector&lt;int&gt; f(n);    for(int i=1;i&lt;n;++i)    &#123;        int j=f[i-1];        while (j&gt;0&amp;&amp;str[i]!=str[j])            j=f[j-1];        /*        后缀长度是下标值 +1(因为我们的下标值是从 0 开始的)        但是根本不成立的时候后缀长度是 0        所以这里需要先比较一次再自增         */        if (str[i]==str[j])            j++;        f[i]=j;    &#125;    return f;&#125;</code></pre><p>里面明明有一个 <code>while</code>，为什么还是线性复杂度的呢？我们尝试去感性理解一下：</p><p>如果想要让这个循环进行次数尽可能的多，我们必须要让 $j$ 尽可能慢的抵达 0 或是尽可能多的遇到 $s_i \neq s_j$ 的情况。如果要让 $j$ 尽可能慢的抵达 0，那最坏情况是前缀函数完全递增，但此时 $s$ 必定由同一种字符组成，所以会因为不满足 $s_i \neq s_j$ 而跳出；如果想要尽可能多的遇到 $s_i \neq s_j$，最坏情况是整个字符串没有相同字符，然而此时 $f$ 的值恒为 0，也会因为不满足 $j&gt;0$ 而跳出。整体复杂度是就可以看做是线性的。</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>最后让我们来看看一开始提出的问题：如何在线性时间复杂度内实现字符串匹配？我们不妨先来模拟一下暴力算法的运算流程，看看哪些步骤是可以简化的。</p><p>（动画 $s=$ <code>abcabcdhijk</code>，$t=$ <code>abcabb</code>， 第一次失配的时候停止） </p><p>停！</p><p>我们往回退一步，确实，这个地方 $s_i$ 是不等于 $t_j$ 的。但如果用人脑的角度去想一想就可以发现，其实大可不必把 $i$ 移到 1、$j$ 移到 0。只需要让 $i$ 不动，$j$ 移到 2 继续开始匹配就好了。只要 $i$ 不回退，因为 $j$ 和 $i$ 是同步运动的，那么整个时间复杂度就是线性的！</p><p>但怎么知道把 $i$ 移到哪里呢？其实和前缀函数优化到线性复杂度的思考方向差不多，这个就交给你啦。给个小提示，因为前面的匹配，我们知道 $t_0 \sim t_{j-1}$ 和原串中的对应部分已经相等，这又有什么奇怪的性质能给我们用呢？</p><p>{task-5}</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>恭喜！</p><p>是的，刚才你所写出的算法其实就是 KMP 算法，它由 Knuth、Pratt 和 Morris 在 1977 年共同发布。它利用前缀函数的性质在线性复杂度内完成了这一任务。而且因为前缀函数可以计算至任意长度，所以它可以做到每当输入一个字符时就进行一次计算，是个很优秀的在线算法。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>本节内容主要参考于：</p><ul><li><a href="http://e-maxx.ru/algo/prefix_function">Префикс-функция. Алгоритм Кнута-Морриса-Пратта</a> （emaxx 的相关文章） 及 <a href="https://oi-wiki.org/string/kmp/">OI Wiki 对此的翻译</a></li><li>《算法导论》</li></ul><p>在此向他们致以由衷的谢意。</p><p>其实前缀函数除了匹配字符串之外还有很多其他有意思的应用，下次我们将会好好聊聊它们。感谢你能够看到这里，我们下次再见！</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《算法竞赛从入门到入坟》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好</title>
      <link href="2020/10/23/%E4%BD%A0%E5%A5%BD/"/>
      <url>2020/10/23/%E4%BD%A0%E5%A5%BD/</url>
      
        <content type="html"><![CDATA[<p>好的由于某些申必原因，天鹏的 blog 源文件貌似全没了，抢修了一下ww</p><hr><p>是的，天鹏有自己的 blog 啦~</p><p>这个 blog 基于 Hexo &amp; Github pages，主题是 @solstice23 的 Argon </p><p>后面会把在其他地方发的一些文章陆陆续续传上这里的~</p><p>欢迎来换友链啊233</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
